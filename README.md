# Encrypted Messages
This project demonstrates a custom encryption scheme combining a stream cipher with RSA for key exchange and HMAC-SHA256 for authenticated encryption (AEAD). It's designed to simulate communication where specific metadata (like iteration numbers) is transmitted in plaintext, alongside the encrypted content.

# Educational only, not real world grade!!!

# How It Works
The system operates in several distinct steps to ensure secure and authenticated communication:

# Step 1: Secure Seed Exchange (RSA)
Seed Generation: A large, cryptographically secure random seed is generated by Alice (the sender) using Python's secrets module. This seed acts as the foundational shared secret for the stream cipher.
Key Generation: Bob (the receiver) generates his asymmetric RSA public and private key pair.
Encrypted Exchange: Alice encrypts her generated seed using Bob's RSA public key.
Decryption & Verification: Alice sends the encrypted seed to Bob. Bob decrypts the seed using his RSA private key. Both parties verify that the decrypted seed matches the original, establishing a shared secret for symmetric encryption.

# Step 2: Message Encryption (Stream Cipher with Plaintext Iteration & HMAC)
Once the shared seed is established, Alice encrypts her message. The final transmitted payload includes both encrypted content and plaintext metadata.

Iteration Number Generation: Alice generates a random iteration number using secrets. This number determines how many times the seed generation process will repeat to produce the key stream. This iteration number will be transmitted in plaintext alongside the encrypted message.
Key Stream Generation: The seedGenerator's iteration function takes the initial shared seed and the generated plaintext iteration number. It processes the seed (iteration times, by taking middle digits and squaring) to produce a complex, pseudo-random key stream number.
Binary Conversion (Internal):
The original plaintext message is converted into its binary representation.
The original length of the message (in bits) is converted into a fixed-size 16-bit binary string.
Content for Encryption: The 16-bit binary length is concatenated with the message binary: [16-bit Length] + [Message Binary].
XOR Encryption: This combined block (length + message binary) is then XORed with the generated key stream binary. This produces the encrypted content.
Final Transmitted Payload Structure: The encrypted content is then concatenated with the plaintext 16-bit binary representation of the iteration number.
Transmitted Structure: [Encrypted (Length + Message)] + [Plaintext (16-bit Iteration)]
ASCII Conversion: This entire binary payload is converted into an ASCII string for transmission.
HMAC-SHA256 Tag: An HMAC-SHA256 authentication tag is generated. This tag is calculated over the entire ASCII payload (which includes both encrypted and plaintext parts) using a key derived from the shared seed. This provides message integrity and authenticity, ensuring the entire transmitted message hasn't been tampered with and comes from a legitimate source.
Output: Alice sends the ASCII payload and the HMAC tag to Bob.

# Step 3: Message Decryption (Stream Cipher with Metadata Extraction & HMAC Verification)
Upon receiving the encrypted message, Bob performs the following steps:

Extract Plaintext Iteration: Bob first extracts the last 16 bits from the received ASCII payload, converting them back to get the plaintext iteration number.
HMAC Verification: Bob derives the same HMAC key from his shared seed. He then recalculates the HMAC-SHA256 tag using the entire received ASCII payload. He compares his recalculated tag with the received tag using hmac.compare_digest() for a secure comparison.
If tags do not match, the message is rejected as potentially tampered with or forged.
If tags match, message integrity and authenticity are confirmed, and decryption proceeds.
Key Stream Re-generation: Using his shared seed and the extracted plaintext iteration number, Bob re-generates the exact same key stream that Alice used.
XOR Decryption: Bob takes the encrypted portion of the received payload (everything before the plaintext iteration) and XORs it with the re-generated key stream. This recovers the original [16-bit Length] + [Message Binary] block.
Metadata Extraction: The first 16 bits of this decrypted block are parsed to get the original message length.
Message Extraction & Conversion: The remaining part of the decrypted block is the message binary. It's trimmed to the original length and converted back into human-readable text.

# Technical Details
RSA Key Size: Primes p and q are 514 bits, resulting in an RSA modulus N of approximately 1028 bits.
Stream Cipher Basis: A custom stream cipher based on squaring middle digits of a seed.
Authentication: HMAC-SHA256 provides message integrity and authenticity for the entire transmitted package.
Metadata Handling: Message length is encrypted and embedded, while the iteration number is transmitted in plaintext as a fixed-size trailing header.


# Future Enhancements
Stronger Key Derivation: Replace str(seed).encode() with a proper Key Derivation Function (KDF) like HKDF for the HMAC key.
Initialization Vector (IV): Consider how an IV could be integrated to enhance security, especially for encrypting multiple messages with the same shared key, even with a plaintext iteration.
Error Handling: Implement more robust error handling for various stages (e.g., failed prime generation, decryption errors).
Standard Cryptography Library Usage: While a great learning exercise, for production-grade security, consider integrating established libraries like cryptography for symmetric encryption (e.g., AES in GCM mode, which includes authentication) and RSA operations.
More Secure Seed Generation: While secrets is good, for extreme cases, consider hardware random number generators (if applicable).
Securing the iteration in the Cipher.
 
